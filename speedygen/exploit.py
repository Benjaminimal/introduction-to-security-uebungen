#!/usr/bin/env python3
import os

from Crypto.PublicKey import RSA

PUB_KEY_DIR = 'pubkeys'
PUB_KEY_EXTENSION = '.pem'


# Iterative version of the extended GCD algorithm. Thx Wikipedia :)
def egcd(b, a):
    x0, x1, y0, y1 = 1, 0, 0, 1
    while a != 0:
        q, b, a = b // a, a, b % a
        x0, x1 = x1, x0 - q * x1
        y0, y1 = y1, y0 - q * y1
    return  b, x0, y0


# Computes the inverse of a modulo m.
def modinv(a, m):
    g, x, y = egcd(a, m)
    if g != 1:
        raise Exception('modular inverse does not exist')
    else:
        return x % m


# Create a directory ignoring errors if it already exists.
def mkdir(name):
    try:
        os.mkdir(name, 0o755)
    except FileExistsError:
        pass


# Save the specified key to file.
def save(key, fname):
    with open(fname, 'wb') as f:
        f.write(key.exportKey())


def pair_zip(lst):
    pairs = []
    for i, x in enumerate(lst):
        for j in range(i, len(lst)):
            y = lst[j]
            if x != y:
                pairs.append((x, y))
    return pairs


def main():
    mkdir('privkeys')

    keys = []
    for file_name in os.listdir(PUB_KEY_DIR):
        with open(os.path.join(PUB_KEY_DIR, file_name), 'r') as f:
            content = f.read()
            key = RSA.importKey(content)
            keys.append(
                {
                    "name": file_name.replace(PUB_KEY_EXTENSION, ""),
                    "key": key,
                }
            )

    pairs = pair_zip(keys)

    for (x, y) in pairs:
        p, _, _ = egcd(x["key"].n, y["key"].n)
        if p > 1:
            q = x["key"].n // p
            d = modinv(x["key"].e, (p-1) * (q-1))
            key = RSA.construct((x["key"].n, x["key"].e, d))
            save(key, 'privkeys/{}.pem'.format(x["name"]))


if __name__ == '__main__':
    main()
